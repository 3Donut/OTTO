<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta name="generator" content="Doxygen 1.8.16" />
    <script type="text/javascript" src="jquery-2.1.1.min.js"></script>
    <title>OTTO: otto::util::algorithm Namespace Reference</title>
    <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
    <script type="text/javascript" src="jquery.powertip.min.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
      <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="bootstrap.min.css">
    <script type="text/javascript" src="bootstrap.min.js"></script>
    <script type="text/javascript" src="doxy-boot.js"></script>
    <link rel="stylesheet" href="jquery.powertip.css">
    <link rel="stylesheet" href="website-styles.css" />
    <link href="doxygen.css" rel="stylesheet" type="text/css" /> <link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <nav class="navbar navbar-fixed-top" role="navigation">
        <div class="container">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
                     <span class="icon-bar"></span>
                     <span class="icon-bar"></span>
                     <span class="icon-bar"></span>
                 </button>
            <a href="." class="navbar-brand">OTTO </a>
            <nav class="collapse navbar-collapse navbar-responsive-collapse">
                <ul class="nav navbar-nav pull-right">
                            <li><a href="index.html">Overview</a></li>
                            <li><a href="annotated.html">Class&nbsp;List</a></li>
                            <li><a href="classes.html">Class&nbsp;Index</a></li>
                            <li><a href="hierarchy.html">Class&nbsp;Hierarchy</a></li>
                            <li><a href="functions.html">Class&nbsp;Members</a></li>
                </ul>
            </nav>
        </div>
    </nav>
    <!-- nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">OTTO ..</a>
        </div>
        </div>
        </nav -->
    <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div class="content" id="content">
            <div class="container">
                <div class="row">
                    <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                        <div style="margin-bottom: 15px;">
                            <!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceotto.html">otto</a></li><li class="navelem"><a class="el" href="namespaceotto_1_1util.html">util</a></li><li class="navelem"><a class="el" href="namespaceotto_1_1util_1_1algorithm.html">algorithm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">otto::util::algorithm Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Inline namespace with algorithms similar to the ones found in the standard <code>&lt;algorithm&gt;</code> header. </p>
<p>Also, this namespace includes container-based wrappers for all standard algorithms. For more on those, see <a class="el" href="group__container__algos.html">Container Standard Algorithms</a></p>
<dl class="section attention"><dt>Attention</dt><dd><code><a class="el" href="namespaceotto_1_1util_1_1algorithm.html" title="Inline namespace with algorithms similar to the ones found in the standard &lt;algorithm&gt; header.">otto::util::algorithm</a></code> is an inline namespace, meaning all members can and should be accessed directly from the <code><a class="el" href="namespaceotto_1_1util.html">otto::util</a></code> namespace i.e. as <code>util::find_if(...)</code>, not <code>util::algorithm::find_if(...)</code>. It is only a separate namespace for clarification of documentation and name resolution. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5c04d6c2475c3066d7363a87ed2146b3"><td class="memTemplParams" colspan="2">template&lt;class StrIterator &gt; </td></tr>
<tr class="memitem:a5c04d6c2475c3066d7363a87ed2146b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#a5c04d6c2475c3066d7363a87ed2146b3">join_strings</a> (StrIterator b, StrIterator e, std::string_view js=&quot;, &quot;)</td></tr>
<tr class="memdesc:a5c04d6c2475c3066d7363a87ed2146b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins a sequence of strings, separating them using <code>js</code>  <a href="#a5c04d6c2475c3066d7363a87ed2146b3">More...</a><br /></td></tr>
<tr class="separator:a5c04d6c2475c3066d7363a87ed2146b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff24d7be3d83d17e63bb8694ca373bb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#aff24d7be3d83d17e63bb8694ca373bb2">string_replace</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;str, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;oldStr, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;newStr)</td></tr>
<tr class="memdesc:aff24d7be3d83d17e63bb8694ca373bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find/Replace.  <a href="#aff24d7be3d83d17e63bb8694ca373bb2">More...</a><br /></td></tr>
<tr class="separator:aff24d7be3d83d17e63bb8694ca373bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9af91b20466d16ad880f62b14bef30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#a1f9af91b20466d16ad880f62b14bef30">starts_with</a> (std::string_view str, std::string_view prefix)</td></tr>
<tr class="memdesc:a1f9af91b20466d16ad880f62b14bef30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if string <code>str</code> starts with <code>prefix</code>  <a href="#a1f9af91b20466d16ad880f62b14bef30">More...</a><br /></td></tr>
<tr class="separator:a1f9af91b20466d16ad880f62b14bef30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee41976b53d2e37704a7079b16800671"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:aee41976b53d2e37704a7079b16800671"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#aee41976b53d2e37704a7079b16800671">join_strings</a> (Container &amp;&amp;cont, std::string_view js=&quot;, &quot;)</td></tr>
<tr class="memdesc:aee41976b53d2e37704a7079b16800671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins a sequence of strings, separating them using <code>js</code>  <a href="#aee41976b53d2e37704a7079b16800671">More...</a><br /></td></tr>
<tr class="separator:aee41976b53d2e37704a7079b16800671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0556bfb35458901dbc0e1cc9de2938"><td class="memTemplParams" colspan="2">template&lt;int n, class Func &gt; </td></tr>
<tr class="memitem:a7e0556bfb35458901dbc0e1cc9de2938"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#a7e0556bfb35458901dbc0e1cc9de2938">generate_array</a> (Func &amp;&amp;gen)</td></tr>
<tr class="separator:a7e0556bfb35458901dbc0e1cc9de2938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae165ffc3104748a9cc9eed173aa0616b"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T &gt; </td></tr>
<tr class="memitem:ae165ffc3104748a9cc9eed173aa0616b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#ae165ffc3104748a9cc9eed173aa0616b">erase</a> (Container &amp;&amp;cont, T &amp;&amp;t)</td></tr>
<tr class="memdesc:ae165ffc3104748a9cc9eed173aa0616b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements from container.  <a href="#ae165ffc3104748a9cc9eed173aa0616b">More...</a><br /></td></tr>
<tr class="separator:ae165ffc3104748a9cc9eed173aa0616b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db9c9649bfeab7f188b9bb79b0676d3"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Pred &gt; </td></tr>
<tr class="memitem:a3db9c9649bfeab7f188b9bb79b0676d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#a3db9c9649bfeab7f188b9bb79b0676d3">erase_if</a> (Container &amp;&amp;cont, Pred &amp;&amp;pred)</td></tr>
<tr class="memdesc:a3db9c9649bfeab7f188b9bb79b0676d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements from container by predicate.  <a href="#a3db9c9649bfeab7f188b9bb79b0676d3">More...</a><br /></td></tr>
<tr class="separator:a3db9c9649bfeab7f188b9bb79b0676d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fff299eec3efa4756fe84e3174d041"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename Size , typename F &gt; </td></tr>
<tr class="memitem:ae4fff299eec3efa4756fe84e3174d041"><td class="memTemplItemLeft" align="right" valign="top">constexpr InputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#ae4fff299eec3efa4756fe84e3174d041">for_each_n</a> (InputIt &amp;&amp;first, Size n, F &amp;&amp;f)</td></tr>
<tr class="separator:ae4fff299eec3efa4756fe84e3174d041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52a84eb6e417ab93533ddef1a6d0705"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename F &gt; </td></tr>
<tr class="memitem:ad52a84eb6e417ab93533ddef1a6d0705"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" href="http://en.cppreference.com/w/namespacestd.html#cpp/types/size_t">std::size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#ad52a84eb6e417ab93533ddef1a6d0705">indexed_for</a> (InputIt &amp;&amp;first, InputIt &amp;&amp;last, F &amp;&amp;f)</td></tr>
<tr class="memdesc:ad52a84eb6e417ab93533ddef1a6d0705"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>for_each</code> with access to an index value.  <a href="#ad52a84eb6e417ab93533ddef1a6d0705">More...</a><br /></td></tr>
<tr class="separator:ad52a84eb6e417ab93533ddef1a6d0705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c7f66cd508eaae726dd3f621ed4435"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F &gt; </td></tr>
<tr class="memitem:ac1c7f66cd508eaae726dd3f621ed4435"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" href="http://en.cppreference.com/w/namespacestd.html#cpp/types/size_t">std::size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#ac1c7f66cd508eaae726dd3f621ed4435">indexed_for</a> (Rng &amp;&amp;rng, F &amp;&amp;f)</td></tr>
<tr class="separator:ac1c7f66cd508eaae726dd3f621ed4435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319b6b968f7db849ded94e5d3e84642e"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class Size , class F &gt; </td></tr>
<tr class="memitem:a319b6b968f7db849ded94e5d3e84642e"><td class="memTemplItemLeft" align="right" valign="top">constexpr InputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#a319b6b968f7db849ded94e5d3e84642e">indexed_for_n</a> (InputIt first, Size n, F &amp;&amp;f)</td></tr>
<tr class="memdesc:a319b6b968f7db849ded94e5d3e84642e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>for_each_n</code> with access to an index value.  <a href="#a319b6b968f7db849ded94e5d3e84642e">More...</a><br /></td></tr>
<tr class="separator:a319b6b968f7db849ded94e5d3e84642e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f4a2a677b86f30b9d87a225ea10c9e"><td class="memTemplParams" colspan="2">template&lt;class Rng , class Size , class F &gt; </td></tr>
<tr class="memitem:a02f4a2a677b86f30b9d87a225ea10c9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" href="http://en.cppreference.com/w/namespacestd.html#cpp/types/size_t">std::size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#a02f4a2a677b86f30b9d87a225ea10c9e">indexed_for_n</a> (Rng &amp;&amp;rng, Size n, F &amp;&amp;f)</td></tr>
<tr class="separator:a02f4a2a677b86f30b9d87a225ea10c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af530b85c1574c138bb8db8ba077f6cdc"><td class="memTemplParams" colspan="2">template&lt;typename Iter1 , typename Iter2 , typename F &gt; </td></tr>
<tr class="memitem:af530b85c1574c138bb8db8ba077f6cdc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#af530b85c1574c138bb8db8ba077f6cdc">for_both</a> (Iter1 &amp;&amp;f1, Iter1 &amp;&amp;l1, Iter2 &amp;&amp;f2, Iter2 &amp;&amp;l2, F &amp;&amp;f)</td></tr>
<tr class="separator:af530b85c1574c138bb8db8ba077f6cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8940b456f15263490c8afc5b4458e2e"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename F &gt; </td></tr>
<tr class="memitem:ac8940b456f15263490c8afc5b4458e2e"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#ac8940b456f15263490c8afc5b4458e2e">for_both</a> (Rng1 &amp;&amp;r1, Rng2 &amp;&amp;r2, F &amp;&amp;f)</td></tr>
<tr class="separator:ac8940b456f15263490c8afc5b4458e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e66a1f7dac3a95e9596570432016c02"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename T &gt; </td></tr>
<tr class="memitem:ga7e66a1f7dac3a95e9596570432016c02"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga7e66a1f7dac3a95e9596570432016c02">accumulate</a> (Cont &amp;&amp;cont, T &amp;&amp;init)</td></tr>
<tr class="memdesc:ga7e66a1f7dac3a95e9596570432016c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/accumulate.html">std::accumulate()</a>  <a href="group__container__algos.html#ga7e66a1f7dac3a95e9596570432016c02">More...</a><br /></td></tr>
<tr class="separator:ga7e66a1f7dac3a95e9596570432016c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad12b6e39e10012394c5c4cef25220513"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename T , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:gad12b6e39e10012394c5c4cef25220513"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gad12b6e39e10012394c5c4cef25220513">accumulate</a> (Cont &amp;&amp;cont, T &amp;&amp;init, BinaryOperation &amp;&amp;op)</td></tr>
<tr class="memdesc:gad12b6e39e10012394c5c4cef25220513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/accumulate.html">std::accumulate()</a>  <a href="group__container__algos.html#gad12b6e39e10012394c5c4cef25220513">More...</a><br /></td></tr>
<tr class="separator:gad12b6e39e10012394c5c4cef25220513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d516fab058229e159e15c3a987b6f02"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:ga7d516fab058229e159e15c3a987b6f02"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga7d516fab058229e159e15c3a987b6f02">for_each</a> (Cont &amp;&amp;cont, UnaryOperation &amp;&amp;op)</td></tr>
<tr class="memdesc:ga7d516fab058229e159e15c3a987b6f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/for_each.html">std::for_each()</a>  <a href="group__container__algos.html#ga7d516fab058229e159e15c3a987b6f02">More...</a><br /></td></tr>
<tr class="separator:ga7d516fab058229e159e15c3a987b6f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga073f917f42b79b632140ec99c45ff1da"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga073f917f42b79b632140ec99c45ff1da"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga073f917f42b79b632140ec99c45ff1da">adjacent_difference</a> (Cont &amp;&amp;cont, OutputIterator &amp;&amp;first)</td></tr>
<tr class="memdesc:ga073f917f42b79b632140ec99c45ff1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/adjacent_difference.html">std::adjacent_difference()</a>  <a href="group__container__algos.html#ga073f917f42b79b632140ec99c45ff1da">More...</a><br /></td></tr>
<tr class="separator:ga073f917f42b79b632140ec99c45ff1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0714070f64afe8451624663804ada8c0"><td class="memTemplParams" colspan="2">template&lt;typename Cont &gt; </td></tr>
<tr class="memitem:ga0714070f64afe8451624663804ada8c0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga0714070f64afe8451624663804ada8c0">prev_permutation</a> (Cont &amp;&amp;cont)</td></tr>
<tr class="memdesc:ga0714070f64afe8451624663804ada8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/prev_permutation.html">std::prev_permutation()</a>  <a href="group__container__algos.html#ga0714070f64afe8451624663804ada8c0">More...</a><br /></td></tr>
<tr class="separator:ga0714070f64afe8451624663804ada8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac96ce17fa44d161d28afe1ae38f8c8b7"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Compare &gt; </td></tr>
<tr class="memitem:gac96ce17fa44d161d28afe1ae38f8c8b7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gac96ce17fa44d161d28afe1ae38f8c8b7">prev_permutation</a> (Cont &amp;&amp;cont, Compare &amp;&amp;comp)</td></tr>
<tr class="memdesc:gac96ce17fa44d161d28afe1ae38f8c8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/prev_permutation.html">std::prev_permutation()</a>  <a href="group__container__algos.html#gac96ce17fa44d161d28afe1ae38f8c8b7">More...</a><br /></td></tr>
<tr class="separator:gac96ce17fa44d161d28afe1ae38f8c8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f85d58817aab2e50690cd54e7688705"><td class="memTemplParams" colspan="2">template&lt;typename Cont &gt; </td></tr>
<tr class="memitem:ga5f85d58817aab2e50690cd54e7688705"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga5f85d58817aab2e50690cd54e7688705">push_heap</a> (Cont &amp;&amp;cont)</td></tr>
<tr class="memdesc:ga5f85d58817aab2e50690cd54e7688705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/push_heap.html">std::push_heap()</a>  <a href="group__container__algos.html#ga5f85d58817aab2e50690cd54e7688705">More...</a><br /></td></tr>
<tr class="separator:ga5f85d58817aab2e50690cd54e7688705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad161b984d06ee40fb4fa3f3e47f95b"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Compare &gt; </td></tr>
<tr class="memitem:gafad161b984d06ee40fb4fa3f3e47f95b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gafad161b984d06ee40fb4fa3f3e47f95b">push_heap</a> (Cont &amp;&amp;cont, Compare &amp;&amp;comp)</td></tr>
<tr class="memdesc:gafad161b984d06ee40fb4fa3f3e47f95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/push_heap.html">std::push_heap()</a>  <a href="group__container__algos.html#gafad161b984d06ee40fb4fa3f3e47f95b">More...</a><br /></td></tr>
<tr class="separator:gafad161b984d06ee40fb4fa3f3e47f95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac924289c208f71eaa44b9a70cac7d6de"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename T &gt; </td></tr>
<tr class="memitem:gac924289c208f71eaa44b9a70cac7d6de"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gac924289c208f71eaa44b9a70cac7d6de">remove</a> (Cont &amp;&amp;cont, T &amp;&amp;value)</td></tr>
<tr class="memdesc:gac924289c208f71eaa44b9a70cac7d6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/remove.html">std::remove()</a>  <a href="group__container__algos.html#gac924289c208f71eaa44b9a70cac7d6de">More...</a><br /></td></tr>
<tr class="separator:gac924289c208f71eaa44b9a70cac7d6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga537015965da3155e9017474ab923e00f"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga537015965da3155e9017474ab923e00f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga537015965da3155e9017474ab923e00f">remove_copy</a> (Cont &amp;&amp;cont, OutputIterator &amp;&amp;first, T &amp;&amp;value)</td></tr>
<tr class="memdesc:ga537015965da3155e9017474ab923e00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/remove_copy.html">std::remove_copy()</a>  <a href="group__container__algos.html#ga537015965da3155e9017474ab923e00f">More...</a><br /></td></tr>
<tr class="separator:ga537015965da3155e9017474ab923e00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf94ae8176e54cd22e816cf6b155ca7e4"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename OutputIterator , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:gaf94ae8176e54cd22e816cf6b155ca7e4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gaf94ae8176e54cd22e816cf6b155ca7e4">remove_copy_if</a> (Cont &amp;&amp;cont, OutputIterator &amp;&amp;first, UnaryPredicate &amp;&amp;p)</td></tr>
<tr class="memdesc:gaf94ae8176e54cd22e816cf6b155ca7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/remove_copy.html">std::remove_copy_if()</a>  <a href="group__container__algos.html#gaf94ae8176e54cd22e816cf6b155ca7e4">More...</a><br /></td></tr>
<tr class="separator:gaf94ae8176e54cd22e816cf6b155ca7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68c5a51467a0a214df053eb0e180bcac"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ga68c5a51467a0a214df053eb0e180bcac"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga68c5a51467a0a214df053eb0e180bcac">remove_if</a> (Cont &amp;&amp;cont, UnaryPredicate &amp;&amp;p)</td></tr>
<tr class="memdesc:ga68c5a51467a0a214df053eb0e180bcac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/remove.html">std::remove_if()</a>  <a href="group__container__algos.html#ga68c5a51467a0a214df053eb0e180bcac">More...</a><br /></td></tr>
<tr class="separator:ga68c5a51467a0a214df053eb0e180bcac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga141e9aacbd49aeaa4574f231bf026e0b"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename T , typename T2 &gt; </td></tr>
<tr class="memitem:ga141e9aacbd49aeaa4574f231bf026e0b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga141e9aacbd49aeaa4574f231bf026e0b">replace</a> (Cont &amp;&amp;cont, T &amp;&amp;old_value, T2 &amp;&amp;new_value)</td></tr>
<tr class="memdesc:ga141e9aacbd49aeaa4574f231bf026e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/replace.html">std::replace()</a>  <a href="group__container__algos.html#ga141e9aacbd49aeaa4574f231bf026e0b">More...</a><br /></td></tr>
<tr class="separator:ga141e9aacbd49aeaa4574f231bf026e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7e2c6490e4e09833e008f7ba3f144a3"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename OutputIterator , typename T , typename T2 &gt; </td></tr>
<tr class="memitem:gae7e2c6490e4e09833e008f7ba3f144a3"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gae7e2c6490e4e09833e008f7ba3f144a3">replace_copy</a> (Cont &amp;&amp;cont, OutputIterator &amp;&amp;first, T &amp;&amp;old_value, T2 &amp;&amp;new_value)</td></tr>
<tr class="memdesc:gae7e2c6490e4e09833e008f7ba3f144a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/replace_copy.html">std::replace_copy()</a>  <a href="group__container__algos.html#gae7e2c6490e4e09833e008f7ba3f144a3">More...</a><br /></td></tr>
<tr class="separator:gae7e2c6490e4e09833e008f7ba3f144a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6582ec00b84fdc8d665c342ec8ef9cea"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename OutputIterator , typename UnaryPredicate , typename T &gt; </td></tr>
<tr class="memitem:ga6582ec00b84fdc8d665c342ec8ef9cea"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga6582ec00b84fdc8d665c342ec8ef9cea">replace_copy_if</a> (Cont &amp;&amp;cont, OutputIterator &amp;&amp;first, UnaryPredicate &amp;&amp;p, T &amp;&amp;new_value)</td></tr>
<tr class="memdesc:ga6582ec00b84fdc8d665c342ec8ef9cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/replace_copy.html">std::replace_copy_if()</a>  <a href="group__container__algos.html#ga6582ec00b84fdc8d665c342ec8ef9cea">More...</a><br /></td></tr>
<tr class="separator:ga6582ec00b84fdc8d665c342ec8ef9cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga732fbeddc4a2d159023ae944662721fe"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename UnaryPredicate , typename T &gt; </td></tr>
<tr class="memitem:ga732fbeddc4a2d159023ae944662721fe"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga732fbeddc4a2d159023ae944662721fe">replace_if</a> (Cont &amp;&amp;cont, UnaryPredicate &amp;&amp;p, T &amp;&amp;new_value)</td></tr>
<tr class="memdesc:ga732fbeddc4a2d159023ae944662721fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/replace.html">std::replace_if()</a>  <a href="group__container__algos.html#ga732fbeddc4a2d159023ae944662721fe">More...</a><br /></td></tr>
<tr class="separator:ga732fbeddc4a2d159023ae944662721fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf5ebd9cb18403c4d55096d6507e17c9"><td class="memTemplParams" colspan="2">template&lt;typename Cont &gt; </td></tr>
<tr class="memitem:gaaf5ebd9cb18403c4d55096d6507e17c9"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gaaf5ebd9cb18403c4d55096d6507e17c9">reverse</a> (Cont &amp;&amp;cont)</td></tr>
<tr class="memdesc:gaaf5ebd9cb18403c4d55096d6507e17c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/reverse.html">std::reverse()</a>  <a href="group__container__algos.html#gaaf5ebd9cb18403c4d55096d6507e17c9">More...</a><br /></td></tr>
<tr class="separator:gaaf5ebd9cb18403c4d55096d6507e17c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa2e9cbe65eea851745d431bbd6877e6"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gafa2e9cbe65eea851745d431bbd6877e6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gafa2e9cbe65eea851745d431bbd6877e6">reverse_copy</a> (Cont &amp;&amp;cont, OutputIterator &amp;&amp;first)</td></tr>
<tr class="memdesc:gafa2e9cbe65eea851745d431bbd6877e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/reverse_copy.html">std::reverse_copy()</a>  <a href="group__container__algos.html#gafa2e9cbe65eea851745d431bbd6877e6">More...</a><br /></td></tr>
<tr class="separator:gafa2e9cbe65eea851745d431bbd6877e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga524d77f7575febee7d064e58fba119a1"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ga524d77f7575febee7d064e58fba119a1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga524d77f7575febee7d064e58fba119a1">rotate</a> (Cont &amp;&amp;cont, ForwardIterator &amp;&amp;new_first)</td></tr>
<tr class="memdesc:ga524d77f7575febee7d064e58fba119a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/rotate.html">std::rotate()</a>  <a href="group__container__algos.html#ga524d77f7575febee7d064e58fba119a1">More...</a><br /></td></tr>
<tr class="separator:ga524d77f7575febee7d064e58fba119a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a7c40459b85d8126a2bf19dba6690a"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gab9a7c40459b85d8126a2bf19dba6690a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gab9a7c40459b85d8126a2bf19dba6690a">rotate_copy</a> (Cont &amp;&amp;cont, ForwardIterator &amp;&amp;new_first, OutputIterator &amp;&amp;first)</td></tr>
<tr class="memdesc:gab9a7c40459b85d8126a2bf19dba6690a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/rotate_copy.html">std::rotate_copy()</a>  <a href="group__container__algos.html#gab9a7c40459b85d8126a2bf19dba6690a">More...</a><br /></td></tr>
<tr class="separator:gab9a7c40459b85d8126a2bf19dba6690a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga990ffbf582e8d0253a5ae474863bdf94"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Cont2 &gt; </td></tr>
<tr class="memitem:ga990ffbf582e8d0253a5ae474863bdf94"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga990ffbf582e8d0253a5ae474863bdf94">search</a> (Cont &amp;&amp;cont, Cont2 &amp;&amp;cont2)</td></tr>
<tr class="memdesc:ga990ffbf582e8d0253a5ae474863bdf94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/search.html">std::search()</a>  <a href="group__container__algos.html#ga990ffbf582e8d0253a5ae474863bdf94">More...</a><br /></td></tr>
<tr class="separator:ga990ffbf582e8d0253a5ae474863bdf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1ef629693495a76e82efc347fa729cb"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Cont2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:gad1ef629693495a76e82efc347fa729cb"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gad1ef629693495a76e82efc347fa729cb">search</a> (Cont &amp;&amp;cont, Cont2 &amp;&amp;cont2, BinaryPredicate &amp;&amp;p)</td></tr>
<tr class="memdesc:gad1ef629693495a76e82efc347fa729cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/search.html">std::search()</a>  <a href="group__container__algos.html#gad1ef629693495a76e82efc347fa729cb">More...</a><br /></td></tr>
<tr class="separator:gad1ef629693495a76e82efc347fa729cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ecafb4137b56cb152c76e92b6da838"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Size , typename T &gt; </td></tr>
<tr class="memitem:gaf4ecafb4137b56cb152c76e92b6da838"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gaf4ecafb4137b56cb152c76e92b6da838">search_n</a> (Cont &amp;&amp;cont, Size count, T &amp;&amp;value)</td></tr>
<tr class="memdesc:gaf4ecafb4137b56cb152c76e92b6da838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/search_n.html">std::search_n()</a>  <a href="group__container__algos.html#gaf4ecafb4137b56cb152c76e92b6da838">More...</a><br /></td></tr>
<tr class="separator:gaf4ecafb4137b56cb152c76e92b6da838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7747ecc67e8778c9ea139b80882b9a25"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Size , typename T , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga7747ecc67e8778c9ea139b80882b9a25"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga7747ecc67e8778c9ea139b80882b9a25">search_n</a> (Cont &amp;&amp;cont, Size count, T &amp;&amp;value, BinaryPredicate &amp;&amp;p)</td></tr>
<tr class="memdesc:ga7747ecc67e8778c9ea139b80882b9a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/search_n.html">std::search_n()</a>  <a href="group__container__algos.html#ga7747ecc67e8778c9ea139b80882b9a25">More...</a><br /></td></tr>
<tr class="separator:ga7747ecc67e8778c9ea139b80882b9a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e1995d5f4063e15a93978b255a9135c"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Cont2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga1e1995d5f4063e15a93978b255a9135c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga1e1995d5f4063e15a93978b255a9135c">set_difference</a> (Cont &amp;&amp;cont, Cont2 &amp;&amp;cont2, OutputIterator &amp;&amp;first)</td></tr>
<tr class="memdesc:ga1e1995d5f4063e15a93978b255a9135c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/set_difference.html">std::set_difference()</a>  <a href="group__container__algos.html#ga1e1995d5f4063e15a93978b255a9135c">More...</a><br /></td></tr>
<tr class="separator:ga1e1995d5f4063e15a93978b255a9135c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga703c6c2347d019dd0ab959e222cb8186"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Cont2 , typename OutputIterator , typename Compare &gt; </td></tr>
<tr class="memitem:ga703c6c2347d019dd0ab959e222cb8186"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga703c6c2347d019dd0ab959e222cb8186">set_difference</a> (Cont &amp;&amp;cont, Cont2 &amp;&amp;cont2, OutputIterator &amp;&amp;first, Compare &amp;&amp;comp)</td></tr>
<tr class="memdesc:ga703c6c2347d019dd0ab959e222cb8186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/set_difference.html">std::set_difference()</a>  <a href="group__container__algos.html#ga703c6c2347d019dd0ab959e222cb8186">More...</a><br /></td></tr>
<tr class="separator:ga703c6c2347d019dd0ab959e222cb8186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga539a8369a85b3c716e0bc82c4d5c3643"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Cont2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga539a8369a85b3c716e0bc82c4d5c3643"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga539a8369a85b3c716e0bc82c4d5c3643">set_intersection</a> (Cont &amp;&amp;cont, Cont2 &amp;&amp;cont2, OutputIterator &amp;&amp;first)</td></tr>
<tr class="memdesc:ga539a8369a85b3c716e0bc82c4d5c3643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/set_intersection.html">std::set_intersection()</a>  <a href="group__container__algos.html#ga539a8369a85b3c716e0bc82c4d5c3643">More...</a><br /></td></tr>
<tr class="separator:ga539a8369a85b3c716e0bc82c4d5c3643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67806761f3ef315aceb35496969e94ff"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Cont2 , typename OutputIterator , typename Compare &gt; </td></tr>
<tr class="memitem:ga67806761f3ef315aceb35496969e94ff"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga67806761f3ef315aceb35496969e94ff">set_intersection</a> (Cont &amp;&amp;cont, Cont2 &amp;&amp;cont2, OutputIterator &amp;&amp;first, Compare &amp;&amp;comp)</td></tr>
<tr class="memdesc:ga67806761f3ef315aceb35496969e94ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/set_intersection.html">std::set_intersection()</a>  <a href="group__container__algos.html#ga67806761f3ef315aceb35496969e94ff">More...</a><br /></td></tr>
<tr class="separator:ga67806761f3ef315aceb35496969e94ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf1d56e41e30a2d31247afc583640e1b"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Cont2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gabf1d56e41e30a2d31247afc583640e1b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gabf1d56e41e30a2d31247afc583640e1b">set_symmetric_difference</a> (Cont &amp;&amp;cont, Cont2 &amp;&amp;cont2, OutputIterator &amp;&amp;first)</td></tr>
<tr class="memdesc:gabf1d56e41e30a2d31247afc583640e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference.html">std::set_symmetric_difference()</a>  <a href="group__container__algos.html#gabf1d56e41e30a2d31247afc583640e1b">More...</a><br /></td></tr>
<tr class="separator:gabf1d56e41e30a2d31247afc583640e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga315f612db3dc8421eaf3b725fd919de7"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Cont2 , typename OutputIterator , typename Compare &gt; </td></tr>
<tr class="memitem:ga315f612db3dc8421eaf3b725fd919de7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga315f612db3dc8421eaf3b725fd919de7">set_symmetric_difference</a> (Cont &amp;&amp;cont, Cont2 &amp;&amp;cont2, OutputIterator &amp;&amp;first, Compare &amp;&amp;comp)</td></tr>
<tr class="memdesc:ga315f612db3dc8421eaf3b725fd919de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference.html">std::set_symmetric_difference()</a>  <a href="group__container__algos.html#ga315f612db3dc8421eaf3b725fd919de7">More...</a><br /></td></tr>
<tr class="separator:ga315f612db3dc8421eaf3b725fd919de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b535a4c41306413d33a3bd77e9a0d38"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Cont2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga1b535a4c41306413d33a3bd77e9a0d38"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga1b535a4c41306413d33a3bd77e9a0d38">set_union</a> (Cont &amp;&amp;cont, Cont2 &amp;&amp;cont2, OutputIterator &amp;&amp;first)</td></tr>
<tr class="memdesc:ga1b535a4c41306413d33a3bd77e9a0d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/set_union.html">std::set_union()</a>  <a href="group__container__algos.html#ga1b535a4c41306413d33a3bd77e9a0d38">More...</a><br /></td></tr>
<tr class="separator:ga1b535a4c41306413d33a3bd77e9a0d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfebe38d19a365d91086c355712c7708"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Cont2 , typename OutputIterator , typename Compare &gt; </td></tr>
<tr class="memitem:gadfebe38d19a365d91086c355712c7708"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gadfebe38d19a365d91086c355712c7708">set_union</a> (Cont &amp;&amp;cont, Cont2 &amp;&amp;cont2, OutputIterator &amp;&amp;first, Compare &amp;&amp;comp)</td></tr>
<tr class="memdesc:gadfebe38d19a365d91086c355712c7708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/set_union.html">std::set_union()</a>  <a href="group__container__algos.html#gadfebe38d19a365d91086c355712c7708">More...</a><br /></td></tr>
<tr class="separator:gadfebe38d19a365d91086c355712c7708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e81fa976d36789c729e13ef142cb225"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename UniformRandomNumberGenerator &gt; </td></tr>
<tr class="memitem:ga4e81fa976d36789c729e13ef142cb225"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga4e81fa976d36789c729e13ef142cb225">shuffle</a> (Cont &amp;&amp;cont, UniformRandomNumberGenerator &amp;&amp;g)</td></tr>
<tr class="memdesc:ga4e81fa976d36789c729e13ef142cb225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/random_shuffle.html">std::shuffle()</a>  <a href="group__container__algos.html#ga4e81fa976d36789c729e13ef142cb225">More...</a><br /></td></tr>
<tr class="separator:ga4e81fa976d36789c729e13ef142cb225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga360e87f6361a2ef70cad1650374391c4"><td class="memTemplParams" colspan="2">template&lt;typename Cont &gt; </td></tr>
<tr class="memitem:ga360e87f6361a2ef70cad1650374391c4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga360e87f6361a2ef70cad1650374391c4">sort</a> (Cont &amp;&amp;cont)</td></tr>
<tr class="memdesc:ga360e87f6361a2ef70cad1650374391c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/sort.html">std::sort()</a>  <a href="group__container__algos.html#ga360e87f6361a2ef70cad1650374391c4">More...</a><br /></td></tr>
<tr class="separator:ga360e87f6361a2ef70cad1650374391c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78e83fc3fdb41c82cbd4666d78ed4d5e"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Compare &gt; </td></tr>
<tr class="memitem:ga78e83fc3fdb41c82cbd4666d78ed4d5e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga78e83fc3fdb41c82cbd4666d78ed4d5e">sort</a> (Cont &amp;&amp;cont, Compare &amp;&amp;comp)</td></tr>
<tr class="memdesc:ga78e83fc3fdb41c82cbd4666d78ed4d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/sort.html">std::sort()</a>  <a href="group__container__algos.html#ga78e83fc3fdb41c82cbd4666d78ed4d5e">More...</a><br /></td></tr>
<tr class="separator:ga78e83fc3fdb41c82cbd4666d78ed4d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00c5848486cb6bdd04626f019e765524"><td class="memTemplParams" colspan="2">template&lt;typename Cont &gt; </td></tr>
<tr class="memitem:ga00c5848486cb6bdd04626f019e765524"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga00c5848486cb6bdd04626f019e765524">sort_heap</a> (Cont &amp;&amp;cont)</td></tr>
<tr class="memdesc:ga00c5848486cb6bdd04626f019e765524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/sort_heap.html">std::sort_heap()</a>  <a href="group__container__algos.html#ga00c5848486cb6bdd04626f019e765524">More...</a><br /></td></tr>
<tr class="separator:ga00c5848486cb6bdd04626f019e765524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga504d2457e084b8e48ef40727335c1bbd"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Compare &gt; </td></tr>
<tr class="memitem:ga504d2457e084b8e48ef40727335c1bbd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga504d2457e084b8e48ef40727335c1bbd">sort_heap</a> (Cont &amp;&amp;cont, Compare &amp;&amp;comp)</td></tr>
<tr class="memdesc:ga504d2457e084b8e48ef40727335c1bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/sort_heap.html">std::sort_heap()</a>  <a href="group__container__algos.html#ga504d2457e084b8e48ef40727335c1bbd">More...</a><br /></td></tr>
<tr class="separator:ga504d2457e084b8e48ef40727335c1bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ba10c8f751ade494f2f97acd60e2ac0"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ga8ba10c8f751ade494f2f97acd60e2ac0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga8ba10c8f751ade494f2f97acd60e2ac0">stable_partition</a> (Cont &amp;&amp;cont, UnaryPredicate &amp;&amp;p)</td></tr>
<tr class="memdesc:ga8ba10c8f751ade494f2f97acd60e2ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/stable_partition.html">std::stable_partition()</a>  <a href="group__container__algos.html#ga8ba10c8f751ade494f2f97acd60e2ac0">More...</a><br /></td></tr>
<tr class="separator:ga8ba10c8f751ade494f2f97acd60e2ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd6c10f284402aca7eabb19d1b223d0"><td class="memTemplParams" colspan="2">template&lt;typename Cont &gt; </td></tr>
<tr class="memitem:ga7cd6c10f284402aca7eabb19d1b223d0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga7cd6c10f284402aca7eabb19d1b223d0">stable_sort</a> (Cont &amp;&amp;cont)</td></tr>
<tr class="memdesc:ga7cd6c10f284402aca7eabb19d1b223d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/stable_sort.html">std::stable_sort()</a>  <a href="group__container__algos.html#ga7cd6c10f284402aca7eabb19d1b223d0">More...</a><br /></td></tr>
<tr class="separator:ga7cd6c10f284402aca7eabb19d1b223d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424087bb73da180e1d9042eb9eb3ab6a"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Compare &gt; </td></tr>
<tr class="memitem:ga424087bb73da180e1d9042eb9eb3ab6a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga424087bb73da180e1d9042eb9eb3ab6a">stable_sort</a> (Cont &amp;&amp;cont, Compare &amp;&amp;comp)</td></tr>
<tr class="memdesc:ga424087bb73da180e1d9042eb9eb3ab6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/stable_sort.html">std::stable_sort()</a>  <a href="group__container__algos.html#ga424087bb73da180e1d9042eb9eb3ab6a">More...</a><br /></td></tr>
<tr class="separator:ga424087bb73da180e1d9042eb9eb3ab6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf42ddbeaa5d530000915b43999e66c7a"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:gaf42ddbeaa5d530000915b43999e66c7a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gaf42ddbeaa5d530000915b43999e66c7a">swap_ranges</a> (Cont &amp;&amp;cont, ForwardIterator &amp;&amp;first)</td></tr>
<tr class="memdesc:gaf42ddbeaa5d530000915b43999e66c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/swap_ranges.html">std::swap_ranges()</a>  <a href="group__container__algos.html#gaf42ddbeaa5d530000915b43999e66c7a">More...</a><br /></td></tr>
<tr class="separator:gaf42ddbeaa5d530000915b43999e66c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dbefdc4aa2a4e3a6fddede5296654fc"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Cont2 , typename F &gt; </td></tr>
<tr class="memitem:ga7dbefdc4aa2a4e3a6fddede5296654fc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga7dbefdc4aa2a4e3a6fddede5296654fc">transform</a> (Cont &amp;&amp;cont, Cont2 &amp;&amp;cont2, F &amp;&amp;f) -&gt; decltype(begin(cont2))</td></tr>
<tr class="memdesc:ga7dbefdc4aa2a4e3a6fddede5296654fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/transform.html">std::transform()</a>  <a href="group__container__algos.html#ga7dbefdc4aa2a4e3a6fddede5296654fc">More...</a><br /></td></tr>
<tr class="separator:ga7dbefdc4aa2a4e3a6fddede5296654fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a374a7c06fbf3a8496587bde58ef54"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Iter , typename F &gt; </td></tr>
<tr class="memitem:ga66a374a7c06fbf3a8496587bde58ef54"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga66a374a7c06fbf3a8496587bde58ef54">transform</a> (Cont &amp;&amp;cont, Iter &amp;&amp;iter, F &amp;&amp;f)</td></tr>
<tr class="memdesc:ga66a374a7c06fbf3a8496587bde58ef54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/transform.html">std::transform()</a>  <a href="group__container__algos.html#ga66a374a7c06fbf3a8496587bde58ef54">More...</a><br /></td></tr>
<tr class="separator:ga66a374a7c06fbf3a8496587bde58ef54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f760297ad374c4c52555a9d4f9cab0c"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Cont2 , typename Cont3 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga3f760297ad374c4c52555a9d4f9cab0c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga3f760297ad374c4c52555a9d4f9cab0c">transform</a> (Cont &amp;&amp;cont, Cont2 &amp;&amp;cont2, Cont3 &amp;&amp;cont3, BinaryPredicate &amp;&amp;f) -&gt; decltype(begin(cont2), begin(cont3))</td></tr>
<tr class="memdesc:ga3f760297ad374c4c52555a9d4f9cab0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/transform.html">std::transform()</a>  <a href="group__container__algos.html#ga3f760297ad374c4c52555a9d4f9cab0c">More...</a><br /></td></tr>
<tr class="separator:ga3f760297ad374c4c52555a9d4f9cab0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab466d6c843265048b7bacbc40f16d9a9"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename InputIterator , typename Cont3 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:gab466d6c843265048b7bacbc40f16d9a9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gab466d6c843265048b7bacbc40f16d9a9">transform</a> (Cont &amp;&amp;cont, InputIterator &amp;&amp;iter, Cont3 &amp;&amp;cont3, BinaryPredicate &amp;&amp;f) -&gt; decltype(begin(cont), begin(cont3))</td></tr>
<tr class="memdesc:gab466d6c843265048b7bacbc40f16d9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/transform.html">std::transform()</a>  <a href="group__container__algos.html#gab466d6c843265048b7bacbc40f16d9a9">More...</a><br /></td></tr>
<tr class="separator:gab466d6c843265048b7bacbc40f16d9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf16f5e5eb939c8565879f0ea07019e0"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Cont2 , typename InputIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:gaaf16f5e5eb939c8565879f0ea07019e0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gaaf16f5e5eb939c8565879f0ea07019e0">transform</a> (Cont &amp;&amp;cont, Cont2 &amp;&amp;cont2, InputIterator &amp;&amp;iter, BinaryPredicate &amp;&amp;f) -&gt; decltype(begin(cont), begin(cont2), iter)</td></tr>
<tr class="memdesc:gaaf16f5e5eb939c8565879f0ea07019e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/transform.html">std::transform()</a>  <a href="group__container__algos.html#gaaf16f5e5eb939c8565879f0ea07019e0">More...</a><br /></td></tr>
<tr class="separator:gaaf16f5e5eb939c8565879f0ea07019e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3849b598c863e3a62cf661323c8b672f"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename InputIterator , typename OutputIterator , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:ga3849b598c863e3a62cf661323c8b672f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga3849b598c863e3a62cf661323c8b672f">transform</a> (Cont &amp;&amp;cont, InputIterator &amp;&amp;firstIn, OutputIterator &amp;&amp;firstOut, BinaryOperation &amp;&amp;op)</td></tr>
<tr class="memdesc:ga3849b598c863e3a62cf661323c8b672f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/transform.html">std::transform()</a>  <a href="group__container__algos.html#ga3849b598c863e3a62cf661323c8b672f">More...</a><br /></td></tr>
<tr class="separator:ga3849b598c863e3a62cf661323c8b672f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab93ee0ea78826ca59ddd7ebc1733675d"><td class="memTemplParams" colspan="2">template&lt;typename Cont &gt; </td></tr>
<tr class="memitem:gab93ee0ea78826ca59ddd7ebc1733675d"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gab93ee0ea78826ca59ddd7ebc1733675d">unique</a> (Cont &amp;&amp;cont)</td></tr>
<tr class="memdesc:gab93ee0ea78826ca59ddd7ebc1733675d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/unique.html">std::unique()</a>  <a href="group__container__algos.html#gab93ee0ea78826ca59ddd7ebc1733675d">More...</a><br /></td></tr>
<tr class="separator:gab93ee0ea78826ca59ddd7ebc1733675d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b58a95aa7399dfd96d6be4d9778edb2"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga2b58a95aa7399dfd96d6be4d9778edb2"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga2b58a95aa7399dfd96d6be4d9778edb2">unique</a> (Cont &amp;&amp;cont, BinaryPredicate &amp;&amp;p)</td></tr>
<tr class="memdesc:ga2b58a95aa7399dfd96d6be4d9778edb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/unique.html">std::unique()</a>  <a href="group__container__algos.html#ga2b58a95aa7399dfd96d6be4d9778edb2">More...</a><br /></td></tr>
<tr class="separator:ga2b58a95aa7399dfd96d6be4d9778edb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc726873dc1a08ade02762ea42624dac"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gacc726873dc1a08ade02762ea42624dac"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gacc726873dc1a08ade02762ea42624dac">unique_copy</a> (Cont &amp;&amp;cont, OutputIterator &amp;&amp;first)</td></tr>
<tr class="memdesc:gacc726873dc1a08ade02762ea42624dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/unique_copy.html">std::unique_copy()</a>  <a href="group__container__algos.html#gacc726873dc1a08ade02762ea42624dac">More...</a><br /></td></tr>
<tr class="separator:gacc726873dc1a08ade02762ea42624dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9c334575fa5e167ed5fe37d4304aeef"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename OutputIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:gac9c334575fa5e167ed5fe37d4304aeef"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gac9c334575fa5e167ed5fe37d4304aeef">unique_copy</a> (Cont &amp;&amp;cont, OutputIterator &amp;&amp;first, BinaryPredicate &amp;&amp;p)</td></tr>
<tr class="memdesc:gac9c334575fa5e167ed5fe37d4304aeef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/unique_copy.html">std::unique_copy()</a>  <a href="group__container__algos.html#gac9c334575fa5e167ed5fe37d4304aeef">More...</a><br /></td></tr>
<tr class="separator:gac9c334575fa5e167ed5fe37d4304aeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f5703c737dae4fe687dde768db101df"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename T &gt; </td></tr>
<tr class="memitem:ga7f5703c737dae4fe687dde768db101df"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga7f5703c737dae4fe687dde768db101df">upper_bound</a> (Cont &amp;&amp;cont, T &amp;&amp;value)</td></tr>
<tr class="memdesc:ga7f5703c737dae4fe687dde768db101df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/upper_bound.html">std::upper_bound()</a>  <a href="group__container__algos.html#ga7f5703c737dae4fe687dde768db101df">More...</a><br /></td></tr>
<tr class="separator:ga7f5703c737dae4fe687dde768db101df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fa3e6aceb5878417a969afa05a7e70f"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:ga1fa3e6aceb5878417a969afa05a7e70f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga1fa3e6aceb5878417a969afa05a7e70f">upper_bound</a> (Cont &amp;&amp;cont, T &amp;&amp;value, Compare &amp;&amp;comp)</td></tr>
<tr class="memdesc:ga1fa3e6aceb5878417a969afa05a7e70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/upper_bound.html">std::upper_bound()</a>  <a href="group__container__algos.html#ga1fa3e6aceb5878417a969afa05a7e70f">More...</a><br /></td></tr>
<tr class="separator:ga1fa3e6aceb5878417a969afa05a7e70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad9288ae8fb47c57d4fe491357e79a96"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gaad9288ae8fb47c57d4fe491357e79a96"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gaad9288ae8fb47c57d4fe491357e79a96">copy</a> (Cont &amp;&amp;cont, OutputIterator &amp;&amp;first)</td></tr>
<tr class="memdesc:gaad9288ae8fb47c57d4fe491357e79a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/copy.html">std::copy()</a>  <a href="group__container__algos.html#gaad9288ae8fb47c57d4fe491357e79a96">More...</a><br /></td></tr>
<tr class="separator:gaad9288ae8fb47c57d4fe491357e79a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga937797401b711b14957d83312dcaa70a"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename OutputIterator , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ga937797401b711b14957d83312dcaa70a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga937797401b711b14957d83312dcaa70a">copy_if</a> (Cont &amp;&amp;cont, OutputIterator &amp;&amp;first, UnaryPredicate &amp;&amp;p)</td></tr>
<tr class="memdesc:ga937797401b711b14957d83312dcaa70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/copy.html">std::copy_if()</a>  <a href="group__container__algos.html#ga937797401b711b14957d83312dcaa70a">More...</a><br /></td></tr>
<tr class="separator:ga937797401b711b14957d83312dcaa70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a9d63fc894ab89786d6b5eb60762513"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename T &gt; </td></tr>
<tr class="memitem:ga4a9d63fc894ab89786d6b5eb60762513"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga4a9d63fc894ab89786d6b5eb60762513">fill</a> (Cont &amp;&amp;cont, T &amp;&amp;value)</td></tr>
<tr class="memdesc:ga4a9d63fc894ab89786d6b5eb60762513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/fill.html">std::fill()</a>  <a href="group__container__algos.html#ga4a9d63fc894ab89786d6b5eb60762513">More...</a><br /></td></tr>
<tr class="separator:ga4a9d63fc894ab89786d6b5eb60762513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga982eb7dc1b8d3dc3c56cb25c3753d3fa"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename T &gt; </td></tr>
<tr class="memitem:ga982eb7dc1b8d3dc3c56cb25c3753d3fa"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga982eb7dc1b8d3dc3c56cb25c3753d3fa">fill_n</a> (Cont &amp;&amp;cont, <a class="elRef" href="http://en.cppreference.com/w/namespacestd.html#cpp/types/size_t">std::size_t</a> n, T &amp;&amp;value)</td></tr>
<tr class="memdesc:ga982eb7dc1b8d3dc3c56cb25c3753d3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/fill_n.html">std::fill_n()</a>  <a href="group__container__algos.html#ga982eb7dc1b8d3dc3c56cb25c3753d3fa">More...</a><br /></td></tr>
<tr class="separator:ga982eb7dc1b8d3dc3c56cb25c3753d3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55284d4fb20ed2d5ec9cc2c3c57b1632"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ga55284d4fb20ed2d5ec9cc2c3c57b1632"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga55284d4fb20ed2d5ec9cc2c3c57b1632">any_of</a> (Cont &amp;&amp;cont, UnaryPredicate &amp;&amp;p)</td></tr>
<tr class="memdesc:ga55284d4fb20ed2d5ec9cc2c3c57b1632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/all_any_none_of.html">std::any_of()</a>  <a href="group__container__algos.html#ga55284d4fb20ed2d5ec9cc2c3c57b1632">More...</a><br /></td></tr>
<tr class="separator:ga55284d4fb20ed2d5ec9cc2c3c57b1632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac791372b539e512b3071ede6215a1937"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:gac791372b539e512b3071ede6215a1937"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gac791372b539e512b3071ede6215a1937">all_of</a> (Cont &amp;&amp;cont, UnaryPredicate &amp;&amp;p)</td></tr>
<tr class="memdesc:gac791372b539e512b3071ede6215a1937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/all_any_none_of.html">std::all_of()</a>  <a href="group__container__algos.html#gac791372b539e512b3071ede6215a1937">More...</a><br /></td></tr>
<tr class="separator:gac791372b539e512b3071ede6215a1937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36b46d8062dc803f3cabb2db51c46382"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ga36b46d8062dc803f3cabb2db51c46382"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga36b46d8062dc803f3cabb2db51c46382">none_of</a> (Cont &amp;&amp;cont, UnaryPredicate &amp;&amp;p)</td></tr>
<tr class="memdesc:ga36b46d8062dc803f3cabb2db51c46382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/all_any_none_of.html">std::none_of()</a>  <a href="group__container__algos.html#ga36b46d8062dc803f3cabb2db51c46382">More...</a><br /></td></tr>
<tr class="separator:ga36b46d8062dc803f3cabb2db51c46382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb22dc1d565ce5c78be43f4b7452ec9f"><td class="memTemplParams" colspan="2">template&lt;typename Cont &gt; </td></tr>
<tr class="memitem:gaeb22dc1d565ce5c78be43f4b7452ec9f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gaeb22dc1d565ce5c78be43f4b7452ec9f">max_element</a> (Cont &amp;&amp;cont)</td></tr>
<tr class="memdesc:gaeb22dc1d565ce5c78be43f4b7452ec9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/max_element.html">std::max_element()</a>  <a href="group__container__algos.html#gaeb22dc1d565ce5c78be43f4b7452ec9f">More...</a><br /></td></tr>
<tr class="separator:gaeb22dc1d565ce5c78be43f4b7452ec9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410ad80e7d5ea282bff422a10ed65836"><td class="memTemplParams" colspan="2">template&lt;typename Cont &gt; </td></tr>
<tr class="memitem:ga410ad80e7d5ea282bff422a10ed65836"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga410ad80e7d5ea282bff422a10ed65836">min_element</a> (Cont &amp;&amp;cont)</td></tr>
<tr class="memdesc:ga410ad80e7d5ea282bff422a10ed65836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/min_element.html">std::min_element()</a>  <a href="group__container__algos.html#ga410ad80e7d5ea282bff422a10ed65836">More...</a><br /></td></tr>
<tr class="separator:ga410ad80e7d5ea282bff422a10ed65836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff18b3f1e7aece740118e65e2a0b7ec2"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Compare &gt; </td></tr>
<tr class="memitem:gaff18b3f1e7aece740118e65e2a0b7ec2"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gaff18b3f1e7aece740118e65e2a0b7ec2">min_element</a> (Cont &amp;&amp;cont, Compare &amp;&amp;f)</td></tr>
<tr class="memdesc:gaff18b3f1e7aece740118e65e2a0b7ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/min_element.html">std::min_element()</a>  <a href="group__container__algos.html#gaff18b3f1e7aece740118e65e2a0b7ec2">More...</a><br /></td></tr>
<tr class="separator:gaff18b3f1e7aece740118e65e2a0b7ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga407ba2c5969dd07eaf52041e1eb549bc"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename Compare &gt; </td></tr>
<tr class="memitem:ga407ba2c5969dd07eaf52041e1eb549bc"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#ga407ba2c5969dd07eaf52041e1eb549bc">max_element</a> (Cont &amp;&amp;cont, Compare &amp;&amp;f)</td></tr>
<tr class="memdesc:ga407ba2c5969dd07eaf52041e1eb549bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/max_element.html">std::max_element()</a>  <a href="group__container__algos.html#ga407ba2c5969dd07eaf52041e1eb549bc">More...</a><br /></td></tr>
<tr class="separator:ga407ba2c5969dd07eaf52041e1eb549bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9f3b07f3956fa6bed7b7adabf0391e"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename T &gt; </td></tr>
<tr class="memitem:gace9f3b07f3956fa6bed7b7adabf0391e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gace9f3b07f3956fa6bed7b7adabf0391e">find</a> (Cont &amp;&amp;cont, T &amp;&amp;t)</td></tr>
<tr class="memdesc:gace9f3b07f3956fa6bed7b7adabf0391e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/find.html">std::find()</a>  <a href="group__container__algos.html#gace9f3b07f3956fa6bed7b7adabf0391e">More...</a><br /></td></tr>
<tr class="separator:gace9f3b07f3956fa6bed7b7adabf0391e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd2199e8cd364fabb6a32702165efc09"><td class="memTemplParams" colspan="2">template&lt;typename Cont , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:gafd2199e8cd364fabb6a32702165efc09"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__container__algos.html#gafd2199e8cd364fabb6a32702165efc09">find_if</a> (Cont &amp;&amp;cont, UnaryPredicate &amp;&amp;f)</td></tr>
<tr class="memdesc:gafd2199e8cd364fabb6a32702165efc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container based wrapper for <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/find.html">std::find_if()</a>  <a href="group__container__algos.html#gafd2199e8cd364fabb6a32702165efc09">More...</a><br /></td></tr>
<tr class="separator:gafd2199e8cd364fabb6a32702165efc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5c04d6c2475c3066d7363a87ed2146b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c04d6c2475c3066d7363a87ed2146b3">&#9670;&nbsp;</a></span>join_strings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StrIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> otto::util::algorithm::join_strings </td>
          <td>(</td>
          <td class="paramtype">StrIterator&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrIterator&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>js</em> = <code>&quot;,&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joins a sequence of strings, separating them using <code>js</code> </p>

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00030">30</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string/append.html">std::string::append()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string/empty.html">std::string::empty()</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/for_each.html">std::for_each()</a>.</p>

<p class="reference">Referenced by <a class="el" href="algorithm_8hpp_source.html#l00062">join_strings()</a>.</p>

</div>
</div>
<a id="aff24d7be3d83d17e63bb8694ca373bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff24d7be3d83d17e63bb8694ca373bb2">&#9670;&nbsp;</a></span>string_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void otto::util::algorithm::string_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>oldStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>newStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find/Replace. </p>

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00043">43</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string/find.html">std::string::find()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string/size.html">std::string::length()</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string/replace.html">std::string::replace()</a>.</p>

</div>
</div>
<a id="a1f9af91b20466d16ad880f62b14bef30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9af91b20466d16ad880f62b14bef30">&#9670;&nbsp;</a></span>starts_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool otto::util::algorithm::starts_with </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if string <code>str</code> starts with <code>prefix</code> </p>

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00055">55</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a id="aee41976b53d2e37704a7079b16800671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee41976b53d2e37704a7079b16800671">&#9670;&nbsp;</a></span>join_strings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> otto::util::algorithm::join_strings </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>js</em> = <code>&quot;,&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joins a sequence of strings, separating them using <code>js</code> </p>

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00062">62</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/begin.html">std::begin()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/end.html">std::end()</a>, and <a class="el" href="algorithm_8hpp_source.html#l00030">join_strings()</a>.</p>

</div>
</div>
<a id="a7e0556bfb35458901dbc0e1cc9de2938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0556bfb35458901dbc0e1cc9de2938">&#9670;&nbsp;</a></span>generate_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, class Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto otto::util::algorithm::generate_array </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00077">77</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a id="ae165ffc3104748a9cc9eed173aa0616b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae165ffc3104748a9cc9eed173aa0616b">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto otto::util::algorithm::erase </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase elements from container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>Must be a container with a <code>erase(Iter, Iter)</code> member function, erasing the items between the two iterators. Most mutable standard containers qualify.</td></tr>
    <tr><td class="paramname">t</td><td>elements will be erased if they compare equal to this</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whatever <code><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#ae165ffc3104748a9cc9eed173aa0616b" title="Erase elements from container.">cont.erase()</a></code> returns. For standard containers, this is the iterator pointing to the element after the last erased one. </dd></dl>

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00093">93</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/begin.html">std::begin()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/end.html">std::end()</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/remove.html">std::remove()</a>.</p>

</div>
</div>
<a id="a3db9c9649bfeab7f188b9bb79b0676d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db9c9649bfeab7f188b9bb79b0676d3">&#9670;&nbsp;</a></span>erase_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto otto::util::algorithm::erase_if </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase elements from container by predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>Must be a container with a <code>erase(Iter, Iter)</code> member function, erasing the items between the two iterators. Most mutable standard containers qualify.</td></tr>
    <tr><td class="paramname">pred</td><td>A predicate that takes a element in the container. Each element for which this predicate returns true will be erased from the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whatever <code><a class="el" href="namespaceotto_1_1util_1_1algorithm.html#ae165ffc3104748a9cc9eed173aa0616b" title="Erase elements from container.">cont.erase()</a></code> returns. For standard containers, this is the iterator pointing to the element after the last erased one. </dd></dl>

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00110">110</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/begin.html">std::begin()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/end.html">std::end()</a>, and <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/remove.html">std::remove_if()</a>.</p>

</div>
</div>
<a id="ae4fff299eec3efa4756fe84e3174d041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fff299eec3efa4756fe84e3174d041">&#9670;&nbsp;</a></span>for_each_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename Size , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr InputIt otto::util::algorithm::for_each_n </td>
          <td>(</td>
          <td class="paramtype">InputIt &amp;&amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00121">121</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="soundfile_8hpp_source.html#l00164">otto::util::SoundFile::write_samples()</a>.</p>

</div>
</div>
<a id="ad52a84eb6e417ab93533ddef1a6d0705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52a84eb6e417ab93533ddef1a6d0705">&#9670;&nbsp;</a></span>indexed_for() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/namespacestd.html#cpp/types/size_t">std::size_t</a> otto::util::algorithm::indexed_for </td>
          <td>(</td>
          <td class="paramtype">InputIt &amp;&amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt &amp;&amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>for_each</code> with access to an index value. </p>
<p>Function called as <code>f(*it, i)</code></p>
<p>For each item in range <code>[first, last)</code>, invoke <code>f</code> with args <code>*iter, i</code> where <code>iter</code> is the current iterator, and <code>i</code> is an incrementing value, starting at zero. Use this instead of raw indexed loops wherever possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Input iterator to the begining of the range </td></tr>
    <tr><td class="paramname">last</td><td>Input iterator to the end of the range </td></tr>
    <tr><td class="paramname">f</td><td>Must be invocable with arguments <code>value_type</code>, <code><a class="elRef" href="http://en.cppreference.com/w/namespacestd.html#cpp/types/size_t">std::size_t</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of iterations performed </dd></dl>

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00141">141</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/algorithm/for_each.html">std::for_each()</a>.</p>

<p class="reference">Referenced by <a class="el" href="algorithm_8hpp_source.html#l00152">indexed_for()</a>.</p>

</div>
</div>
<a id="ac1c7f66cd508eaae726dd3f621ed4435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c7f66cd508eaae726dd3f621ed4435">&#9670;&nbsp;</a></span>indexed_for() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/namespacestd.html#cpp/types/size_t">std::size_t</a> otto::util::algorithm::indexed_for </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00152">152</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/begin.html">std::begin()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/end.html">std::end()</a>, and <a class="el" href="algorithm_8hpp_source.html#l00141">indexed_for()</a>.</p>

</div>
</div>
<a id="a319b6b968f7db849ded94e5d3e84642e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319b6b968f7db849ded94e5d3e84642e">&#9670;&nbsp;</a></span>indexed_for_n() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class Size , class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr InputIt otto::util::algorithm::indexed_for_n </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>for_each_n</code> with access to an index value. </p>
<p>Function called as <code>f(*it, i)</code></p>
<p>for <code>n</code> iterations, invoke <code>f</code> with args <code>*iter, i</code> where <code>iter</code> is the current iterator starting with <code>first</code>, and <code>i</code> is an incrementing value, starting at zero. Use this instead of raw indexed loops wherever possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Input iterator to the begining of the range </td></tr>
    <tr><td class="paramname">n</td><td>Number of iterations to go through </td></tr>
    <tr><td class="paramname">f</td><td>Must be invocable with arguments <code>value_type</code>, <code><a class="elRef" href="http://en.cppreference.com/w/namespacestd.html#cpp/types/size_t">std::size_t</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator one past the last one visited </dd></dl>

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00170">170</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="algorithm_8hpp_source.html#l00179">indexed_for_n()</a>.</p>

</div>
</div>
<a id="a02f4a2a677b86f30b9d87a225ea10c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f4a2a677b86f30b9d87a225ea10c9e">&#9670;&nbsp;</a></span>indexed_for_n() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rng , class Size , class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/namespacestd.html#cpp/types/size_t">std::size_t</a> otto::util::algorithm::indexed_for_n </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Size&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00179">179</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/begin.html">std::begin()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/end.html">std::end()</a>, and <a class="el" href="algorithm_8hpp_source.html#l00170">indexed_for_n()</a>.</p>

</div>
</div>
<a id="af530b85c1574c138bb8db8ba077f6cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af530b85c1574c138bb8db8ba077f6cdc">&#9670;&nbsp;</a></span>for_both() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter1 , typename Iter2 , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void otto::util::algorithm::for_both </td>
          <td>(</td>
          <td class="paramtype">Iter1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>l2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00185">185</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="algorithm_8hpp_source.html#l00195">for_both()</a>.</p>

</div>
</div>
<a id="ac8940b456f15263490c8afc5b4458e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8940b456f15263490c8afc5b4458e2e">&#9670;&nbsp;</a></span>for_both() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void otto::util::algorithm::for_both </td>
          <td>(</td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00195">195</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

<p class="reference">References <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/begin.html">std::begin()</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/end.html">std::end()</a>, and <a class="el" href="algorithm_8hpp_source.html#l00185">for_both()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<address class="footer">
  <small>Version: ..  | Generated by <a href="http://www.doxygen.org/index.html"> Doxygen 1.8.16</a></small>
</address>
</body>
</html>
